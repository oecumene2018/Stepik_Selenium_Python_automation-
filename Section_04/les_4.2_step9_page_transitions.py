#
# ПЕРЕХОДЫ МЕЖДУ СТРАНИЦАМИ
#
# Переход можно реализовать двумя разными способами.
#
# Первый способ: возвращать нужный Page Object.
#
# Для этого в файле main_page.py нужно сделать импорт страницы с логином:
#
# from .login_page import LoginPage
# Затем в методе, который осуществляет переход к странице логина, проинициализировать новый объект Page и вернуть его:
#
def go_to_login_page(self):
    link = self.browser.find_element(*MainPageLocators.LOGIN_LINK)
    link.click()
    return LoginPage(browser=self.browser, url=self.browser.current_url)
# Обратите внимание! При создании объекта мы обязательно передаем ему тот же самый объект драйвера для работы
# с браузером, а в качестве url передаем текущий адрес.
#
# Теперь в тесте нам не нужно думать про инициализацию страницы: она уже создана. Сохранив возвращаемое значение
# в переменную, мы можем использовать методы новой страницы в тесте:

def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com"
    page = MainPage(browser, link)
    page.open()
    login_page = page.go_to_login_page()
    login_page.should_be_login_page()

# Плюсы такого подхода:
#
# тест выглядит аккуратнее — не нужно инициализировать страницу в теле теста;
# явно возвращаем страницу — тип страницы ассоциирован с методом;
# не нужно каждый раз думать в разных тестах про инициализацию страницы — уменьшаем дублирование кода;
# минусы:
#
# если у нас копится большое количество страниц и переходов — образуется много перекрестных импортов;
# большая связность кода — при изменении логики придется менять возвращаемое значение;
# сложнее понимать код, так как страница инициализируется неявно;
# образуются циклические зависимости, что часто приводит к ошибкам.
# Второй подход: переход происходит неявно, страницу инициализируем в теле теста:
#
# 1. Закомментируйте строку с возвращаемым значением

def go_to_login_page(self):
    link = self.browser.find_element(*MainPageLocators.LOGIN_LINK)
    link.click()
    # return LoginPage(browser=self.browser, url=self.browser.current_url)

# 2. Инициализируем LoginPage в теле теста (не забудьте импортировать в файл нужный класс):

from .pages.login_page import LoginPage

def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com"
    page = MainPage(browser, link)
    page.open()
    page.go_to_login_page()
    login_page = LoginPage(browser, browser.current_url)
    login_page.should_be_login_page()

# Плюсы:
#
# меньше связность кода;
# меньше импортов, нет перекрестных импортов;
# больше гибкость;
# в тесте понятнее что происходит, т.к. явно инициализируем страницу.

# Минусы:
#
# появляется лишний шаг в тест-кейсе;
# каждый раз при написании теста нужно думать про корректные переходы;
# дублируется код.
# И тот и другой подход можно успешно применять в своих проектах, главное делать это с умом. Сейчас оставьте
# второй вариант с явной инициализацией страниц в теле теста, чтобы избежать лишних сложностей
# с циклическими зависимостями.
#
# Уберите лишний закомментированный код, и зафиксируйте изменения в коммите с осмысленным сообщением.
